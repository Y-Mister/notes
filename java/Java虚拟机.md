### Java虚拟机

#### 运行时数据区域

1. ##### JVM运行时数据区域划分

   执行java程序过程中会将它所管理的内存划分为以下数据区域

   > 包括：
   >
   > 方法区 method area；
   >
   > 虚拟机栈 VM Stack；
   >
   > 本地方法栈 Native Method Stack；
   >
   > 堆 heap；
   >
   > 程序计数器 Program Couter Register;
   >
   > 注意：方法区和堆是线程共享的，而每个线程都有自己的程序计数器、本地方法栈和虚拟机栈



2. ##### 程序计数器

   > **线程私有**；
   >
   > 如果线程执行的是一个java方法，则其作用是当前线程所执行的字节码的行号指示器，它指明了当前线程所执行到的地方，使得线程切换后能够恢复到正确的执行位置；若线程执行的是Native方法，则计数器值为空；
   >
   > 程序计数器是java虚拟机中唯一没有规定内存溢出错误（OutOfMemoryError）的区域



3. ##### Java虚拟机栈（JVMS）

   > **线程私有；**
   >
   > 生命周期与线程相同；
   >
   > 用于描述java方法执行的内存模型：线程的每个方法被执行都会创建一个**栈帧**用于存储该方法的**局部变量表(本地变量表)**、**操作栈**、**动态链接**、**方法出口**等信息。一个方法从被调用到执行结束的过程，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程；
   >
   > 栈帧中保存的局部变量表内存在编译期间完成分配；
   >
   > 区域异常：线程请求栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；虚拟机栈的动态扩展无法申请到足够的内存时抛出OutOfMemoryError;

   局部变量（local veriable）

4. ##### 本地方法栈（NMS）

   > 与VMS类似，区别在于VMS为java方法服务，而NMS为Native方法服务；
   >
   > 异常：与VMS相同的StackOverflowError与OutOfMemoryError异常；



5. ##### Java堆（heap）

   > **线程共享；**
   >
   > 虚拟机启动时创建；
   >
   > 用于存放创建好的对象实例（所有的对象实例与数组都会在堆上分配内存）；
   >
   > 堆的内存在物理上不一定连续，但逻辑上连续（可扩展，若无法继续扩展，会抛出OutOfMemoryError异常）
   >
   > 是GC管理的主要区域



6. ##### 方法区（method area）

   > **线程共享；**
   >
   > 存放已被虚拟机加载的类的代码、类信息、常量、静态变量等数据（即存放运行中不会变的东西）；
   >
   > GC较少处理此区域；
   >
   > 若方法区无法申请到足额的内存扩展空间，抛出OutOfMemoryError异常



7. ##### 运行时常量池

   > 属于方法区的一部分；
   >
   > 存放编译器生成的各种Java量与符号引用，此外，翻译出来的直接引用也存储在运行时常量池中；
   >
   > 运行时常量池具备动态性，java并不要求常量一定要在编译期间产生，运行期间也可能将新的常量放入池中（例如String 的 intern()方法）；
   >
   > 其受到方法区的限制，当常量池无法申请到足够的内存时排除OutOfMemoryError异常；



#### 对象访问

1. ##### 关于对象的访问

   > 涉及到java栈，java堆与方法区

   ```java
   Objec obj = new Object();
   /*以上述语句为例，Object obj将会反应到java虚拟机栈的本地变量表中，作为reference类型数据出现；而new Object()方法则反应为在java堆中形成一块存储Object类型所有实例数据的结构化内存；
   而reference类型数据值规定了指向对象的引用，并没有指明该引用通过何种方式去定位，主流的访问方式有：使用句柄和直接指针
   */
   ```



2. 使用句柄方式

   > java堆中会划分一块内存为句柄池，reference中存储的对象就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息

   ![1564736747436](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1564736747436.png)



3. 使用直接指针访问方式

   > reference中直接存储的就是对象地址

   ![1564736977307](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1564736977307.png)



4. 句柄与直接指针方式的区别

   > 直接指正方式较为稳定，当对象地址更改是只需要更改句柄保存的对象地址，而不需要改变reference数据的内容；
   >
   > 而直接指针相比句柄少了一次句柄到对象数据的定位过程，速度快；



#### 垃圾收集器与内存分配策略

1. ##### 垃圾分类算法

   引用计数算法

   > 给对象添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1,任何时刻计数器都为0的对象就是不可能再被使用的；
   >
   > 问题：文法解决相互循环引用的问题

    ```java
   public class ReferenceCounting {
   
       public Object instace = null;
       private static final int _1MB = 1024*1024;
   
       private byte[] bigSize = new byte[2*_1MB];
   
       public static void testGC(){
           ReferenceCounting objA = new ReferenceCounting();
           ReferenceCounting objB = new ReferenceCounting();
           objA.instace = objB;
           objB.instace = objA;
   
           objA = null;
           objB = null;
           System.gc();
       }
   
       public static void main(String[] args) {
           ReferenceCounting.testGC();
       }
   
   }
   /*此处虽然objA、objB都置空，但是因为它们互相引用着对方，使得GC引用计数法无法进行垃圾回收；但是，此处java的GC仍然能够回收，因为java不再使用引用计数法*/
    ```

   可达性分析算法（根搜索算法）

   > 通过一系列的GC ROOTS的对象作为起始点，从这些节点向下搜索，搜索多经过的路径称为引用链，当一个对象到GC ROOTS没有任何引用链相连时（即从GC ROOTS到该对象不可达），则判定该对象不可用可回收；
   >
   > 可作为GC ROOTS的对象：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中的类静态属性引用的对象、方法区中的常量引用的对象、本地方法栈中Native方法的引用的对象

   引用的概念扩充

   > 无论是引用计数还是可达性分析，都关系到引用，而引用可分为强引用（Strong reference/）、软引用（soft reference）、弱引用（Weak reference）、虚引用（Phantom reference）

   > **强引用**就是代码中普遍存在的，类似Objec obj = new Object()此类，只有强引用还存在，垃圾回收期永远不会回收掉被引用的对象；
   >
   > **软引用**描述一些还有用，但非必须的对象，对于软引用关联着的对象，在系统将要发生内存泄露之前，将会把这些对象列进到回收范围之中进行第二次回收，如果此次回收任没有足够的内存，才会抛出内存溢出异常，jdk提供SoftReference类来实现软引用；
   >
   > **弱引用**也描述非必须的对象，比弱引用强度更若，被弱引用关联的对象只能存活到下一次垃圾回收发生之前。当垃圾回收器工作时，无论当前内存是否充足，都会回收掉弱引用对象。jdk提供WeakReference类实现弱引用；
   >
   > **虚引用**是最弱的引用关系，一个对象是否有虚引用的存在完全不影响其生存时间，也无法通过虚引用来取得一个对象实例。为对象设置一个虚引用关联的唯一目的就是希望该对象被垃圾回收器回收之前收到一个系统通知。jdk提供PhantomReference类实现虚引用。

2. ##### 方法区的垃圾回收

   > 废弃常量的定义：若没有任何对象/没有任何对象对某个常量进行引用，则该常量可能会被清除常量池；
   >
   > 无用的类的定义：该类所有实例均被回收，java堆中不存在该类的任何实例；加载该类的ClassLoader以及被回收；该类对应的java。lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法。虚拟机**可以**对满足上述三个条件的类进行回收

3. ##### 垃圾收集算法

   > 标记清除算法、复制算法、标记整理算法、分代收集算法

   标记—清除算法

   > 首先标记处所有需要回收的对象，标记完成后统一回收；
   >
   > 缺点：标记与清除的效率不高；空间问题，标记清除会产生大量的内存碎片

   复制算法

   > 将内存等分两份，每次只使用其中一块。当此块内存用完，将仍然存活的对象复制到另一块内存上，然后将前一块内存统一清理；
   >
   > 解决了内存碎片化的问题，实现简单，运行高效，但内存使用率大大降低

   分代垃圾回收算法

   > 即年轻代、年老代，持久代的划分，jvm将内存分为Eden、survivor、old分区，survivor还划分为from和to；
   >
   > 垃圾回收的流程：
   >
   > 1. 新创建的对象，多数放入Eden区；
   > 2. 当Eden满了不能创建新的对象，触发minor GC，将无用对象清理掉，剩余对象放入survivor中的from区，同时清空Eden；
   > 3. 当Eden再次满，同时将Eden中的不能清除的对象复制到from，然后将from区的不能清空的对象存入到to区，最后清空Eden和from区（from区与to区不存在实际差别，他们两在每次只需minorGC是会交换职责，如第一次minorGC将Eden和from区存货对象赋值到to区，那么第二次minorGC将会将Eden与to区的存活对象赋值到from区，依次类推）
   > 4. 重复多次（默认最大15次），survivor区中任然没有被清理的对象，将会复制到old区中
   > 5. 当old区满了（或达到某个比例），将会触发major GC,触发stop-the-world，清空old区
   > 6. note:还有一个full GC,同时清理年轻代，年老代区域，成本较高，会对系统性能产生影响；导致full GC的原因：年老代写满；持久-代写满；System.gc()的显示调用；上一次GC之后Heap的各域分配策略动态变化

   标记—整理算法

   > 标记过程与标记—整理算法一致，但后续的清理则不同，标记—整理算法是让所有存活对象向一端移动，随后清除掉存活边界意外的内存

4. ##### 收集器

   > 深入理解java虚拟机3.4

5. ##### 内存分配与回收策略

   > 大多数情况下，对象在新生代Eden区中分配，**当Eden区没有足够的空间进行分配时，虚拟机将发起一次minorGC**；
   >
   > 而大对象则直接进入老年代，大对象指的是需要大量连续空间的java对象（例如长字符串与数组），大对象直接在老年代，避免了在Eden区的两个survivor区的大量内存拷贝
   >
   > 长期存活对象将进入老年代，对此，虚拟机给每个对象定义了一个对象年龄（Age）计数器，对象再Eden区出生并经历过第一次MinorGC后仍然存活，并且可被Survivor容纳的话，对象将被移动到survivor区，此后对象每在survivor中度过一次MinorGC并存活，则其年龄增加一岁，当期年龄增加到一定值（默认为15），则将会被晋升到老年代中，年龄阈值可通过参数-XX:MaxTenuringThreshold设置

6. 动态对象年龄判定

   > 针对长期存活对象，为了适应不同的内存状况，并不一定要求对象年龄一定要达到阈值才能晋升老年代，如果survivor中相同年龄的所有对象大小总和大于survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等待阈值要求

7. #####  minorGC与fullGC的区别

   > **MinorGC**是新生代GC，指发生在新生代的垃圾回收动作，因此java对象大多具有朝生夕死的特性，所以minorGC非常频繁，一般回收速度也比较快;
   >
   > **MajorGC/FullGC**是老年代GC，指发生在老年代的GC,出现了majorGC，经常会伴随着至少一次的minorGC(非绝对，收集器不同可能存在区别)，majorGC一般会比minorGC慢10倍以上

8. ##### 空间分配担保

   > 在发生minorGC时，虚拟机会检测**之前**每次晋升到老年代的**平均大小**是否大于老年代的剩余空间，如果大于，则改为直接进行一次FullGC；如果小于，则查看HandlerPromotionFailure设置是否允许担保失败，如果允许，那只会进行MinorGC，如果不允许，则也要改为进行一次FullGC；
   >
   > 所谓担保，即虚拟机采用复制收集算法采用survivor中的一个作为轮换备份，当一次minorGC后仍然有大量对象存活，则需要老年代进行分配担保，让survivor区无法存放的对象直接进入老年代，前提是老年代空间足够，此算法采用平均值作为参考值，与老年代大小进行比较，决定是否采用fullGC来让老年代腾出空间给新生代对象（深入理解java虚拟机3.5.5）





#### 虚拟机性能监控与故障处理

深入理解java虚拟机第四章 以下均可通过  command -h查看命令格式

主要工具及调用事例

1. jsp虚拟机进程状况工具

   > 命令格式：jsp [options] [hostid]
   >
   > 例如jsp  -l ：输出当前虚拟机执行的进程

   常用options

   | options | 作用                                                         |
   | ------- | ------------------------------------------------------------ |
   | -q      | 只输出**LVMID**,省略主类的名称                               |
   | -m      | 输出虚拟机进程启动时传递给主类main函数的参数                 |
   | -l      | 输出**LVMID**,主类的全名，如果进程执行的是jar包，输出jar包路径 |
   | -v      | 输出虚拟机进程启动时JVM参数                                  |

   

2. jstat虚拟机统计信息监视工具

   > 用于监视虚拟机各种运行状态信息的工具，可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据
   >
   > 命令格式：
   >
   > jstat [option vmid   [   interval[s [ms]  [count] ]    ]     ]
   >
   > 如果是本地虚拟机进程VMID与LVMIDs 一致的，如果是远程虚拟机进程，则VMID格式为：[ protocal: ] [//] lvmid [@hostname [:port] /servername ]
   >
   > interval与count 参数代表查询间隔和次数，若省略则表示只查询一次
   
   可用option参数
   
   | 选项              | 作用                                                         |
   | ----------------- | ------------------------------------------------------------ |
   | -class            | 监视类装载、卸载数量、总空间及类装载所耗费的时间             |
   | -gc               | 监视java堆状况，包括Eden区、2个survivor区、老年代、永久代等的容量、医用空间、GC时间合计等信息 |
   | -gccapacity       | 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最小的空间 |
   | -gcutil           | 监视内容与-gc基本相同，但输出主要关注已使用空间占占总空间的百分比 |
   | -gccause          | 与-gcutil功能相同，但会额外输出导致上一次GC产生的原因        |
   | -gcnew            | 监视新生代GC的状况                                           |
   | -gcnewcapacity    | 监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间 |
   | -gcold            | 监视老年代GC状况                                             |
   | -gcoldcapacity    | 监视内容与-gcold基本相同，输出主要关注使用到的最大和最小空间 |
   | -gcpermcapacity   | 输出永久代使用到的最小和最大空间                             |
   | -compailer        | 输出JIT编译器编译过的方法、耗时等信息                        |
   | -printcompilation | 输出已经被JIT编译的方法                                      |
   
   参数信息：部分可见深入理解java虚拟机p102



3. jinfo：Java配置信息工具

   > 实时地查看和调整虚拟机的各项参数（p103）
   >
   > 可以在运行期修改虚拟机部分参数，使用 -flag [+|-]name或者 -flag name=value方式改写；
   >
   > 命令格式：
   >
   > jinfo [option] pid 

   option参数提供：（根据JDK1.8查询到的可用option）

   | 选项                     | 作用                    |
   | ------------------------ | ----------------------- |
   | -flag  < name >          | 来查看未显示指定的参数  |
   | -flag  [+\|-]< name >    | 启用/禁用某一虚拟机参数 |
   | -flag  < name >=< value> | 给虚拟机参数设值        |
   | -flags                   | 打印虚拟机参数          |
   | -sysprops                | 打印java系统属性        |
   | < no option >            | 打印以上所有            |

   

4. jmap：Java内存印象工具

   > 生成堆存储快照（heapdump/dump文件）、查询finalize执行队列、java堆和永久代的详细信息（如空间利用率、当前是什么垃圾收集器等）
   >
   > 命令格式：
   >
   > jamp [option] < pid > :连接正在运行的进程
   >
   > jmap [option] < exxcutable < core > >:连接核心文件
   >
   > jmap [option] [server_id@] < remote server IP or hostname>:连接远程调试服务器

   可选参数：

   | 参数                  | 作用                                                         |
   | --------------------- | ------------------------------------------------------------ |
   | < none>               | 打印与Solaris pmap相同的内容                                 |
   | -heap                 | 打印java堆概要信息                                           |
   | -histo[:live]         | 打印java对象堆的直方图，如果指定live，则只打印活对象         |
   | -clstats              | 打印类加载器统计信息                                         |
   | -finalizerinfo        | 打印等待完成的对象信息                                       |
   | -dump:< dump-options> | 生成java堆转储快照，dump-options包括：live :是否只打印活的对象；format=b：二进制形式；file=< file> 生成堆到文件 |
   | -F                    | 强制生成堆快照，此状态下live参数不可用                       |
   | -J< flag>             |                                                              |
   |                       |                                                              |

   